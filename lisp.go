package main

import (
	"fmt"
	"strings"

	"github.com/eigenhombre/lexutil"
)

// Sexpr is a general-purpose data structure for representing
// S-expressions.
type Sexpr interface {
	String() string
	Equal(Sexpr) bool
}

// ConsCell is a cons cell.  Use Cons to create one.
type ConsCell struct {
	car Sexpr
	cdr Sexpr
}

// Nil is the empty list / cons cell.  Cons with Nil to create a list
// of one item.
var Nil *ConsCell = nil

func (c *ConsCell) String() string {
	ret := "("
	for car := c; car != Nil; car = car.cdr.(*ConsCell) {
		ret += car.car.String()
		if car.cdr != Nil {
			ret += " "
		}
	}
	return ret + ")"
}

// Cons creates a cons cell.
func Cons(i Sexpr, cdr *ConsCell) *ConsCell {
	return &ConsCell{i, cdr}
}

// Equal returns true iff the two S-expressions are equal cons-wise
func (c *ConsCell) Equal(o Sexpr) bool {
	_, ok := o.(*ConsCell)
	if !ok {
		return false
	}
	if c == Nil {
		return o == Nil
	}
	if o == Nil {
		return c == Nil
	}
	return c.car.Equal(o.(*ConsCell).car) && c.cdr.Equal(o.(*ConsCell).cdr)
}

// evLambda evaluates f in a new environment generated by adding bindings for each
// of the args to the current environment:
func (f *lambdaFn) evLambda(args []Sexpr) (Sexpr, error) {
	newEnv := mkEnv(f.env)
	if len(f.args) != len(args) {
		return nil, fmt.Errorf("wrong number of args: %d != %d", len(f.args), len(args))
	}
	for i, arg := range f.args {
		newEnv.Set(arg, args[i])
	}
	if f.body == Nil {
		return Nil, nil
	}

	for {
		ret, err := eval(f.body.car, &newEnv)
		if err != nil {
			return nil, err
		}
		if f.body.cdr == Nil {
			return ret, nil
		}
		f.body = f.body.cdr.(*ConsCell)
	}
}

func evList(expr *ConsCell, e *env) ([]Sexpr, error) {
	ret := []Sexpr{}
	for ; expr != Nil; expr = expr.cdr.(*ConsCell) {
		ee, err := eval(expr.car, e)
		if err != nil {
			return nil, err
		}
		ret = append(ret, ee)
	}
	return ret, nil
}

func stringFromList(l *ConsCell) string {
	ret := []string{}
	for ; l != Nil; l = l.cdr.(*ConsCell) {
		ret = append(ret, l.car.String())
	}
	return strings.Join(ret, " ")
}

func evErrors(args *ConsCell, e *env) (Sexpr, error) {
	if args == Nil {
		return nil, fmt.Errorf("no error spec given")
	}
	sigExpr, ok := args.car.(*ConsCell)
	if !ok {
		return nil, fmt.Errorf("error signature must be a list")
	}
	sigEvaled, err := eval(sigExpr, e)
	if err != nil {
		return nil, err
	}
	sigList, ok := sigEvaled.(*ConsCell)
	if !ok {
		return nil, fmt.Errorf("error signature must be a list")
	}
	errorStr := stringFromList(sigList)
	bodyArgs := args.cdr.(*ConsCell)
	for {
		if bodyArgs == Nil {
			return nil, fmt.Errorf("error not found")
		}
		toEval := bodyArgs.car
		_, err := eval(toEval, e)
		if err != nil {
			if strings.Contains(err.Error(), errorStr) {
				return Nil, nil
			}
			return nil, fmt.Errorf("error '%s' not found in '%s'",
				errorStr, err.Error())
		}
		bodyArgs = bodyArgs.cdr.(*ConsCell)
	}
}

// applyFn applies a function to an already-evaluated list of arguments.
func applyFn(fnCar Sexpr, args []Sexpr) (Sexpr, error) {
	// User-defined functions:
	lambda, ok := fnCar.(*lambdaFn)
	if ok {
		return lambda.evLambda(args)
	}
	// Built-in functions:
	builtin, ok := fnCar.(*Builtin)
	if !ok {
		return nil, fmt.Errorf("%s is not a function", fnCar)
	}
	biResult, err := builtin.Fn(args)
	if err != nil {
		return nil, err
	}
	return biResult, nil

}

func eval(expr Sexpr, e *env) (Sexpr, error) {
	switch t := expr.(type) {
	case Atom:
		if t.s == "t" {
			return expr, nil
		}
		ret, ok := e.Lookup(t.s)
		if ok {
			return ret, nil
		}
		ret, ok = builtins[t.s]
		if ok {
			return ret, nil
		}
		return nil, fmt.Errorf("unknown symbol: %s", t.s)
	case Number:
		return expr, nil
	case *ConsCell:
		if t == Nil {
			return Nil, nil
		}
		// special forms:
		if carAtom, ok := t.car.(Atom); ok {
			switch {
			case carAtom.s == "quote":
				return t.cdr.(*ConsCell).car, nil
			case carAtom.s == "cond":
				pairList := t.cdr.(*ConsCell)
				if pairList == Nil {
					return Nil, nil
				}
				for {
					if pairList == Nil {
						return Nil, nil
					}
					pair := pairList.car.(*ConsCell)
					ev, err := eval(pair.car, e)
					if err != nil {
						return nil, err
					}
					if ev == Nil {
						pairList = pairList.cdr.(*ConsCell)
						continue
					}
					return eval(pair.cdr.(*ConsCell).car, e)
				}
			case carAtom.s == "def":
				pair := t.cdr.(*ConsCell)
				name := pair.car.(Atom).s
				val, err := eval(pair.cdr.(*ConsCell).car, e)
				if err != nil {
					panic(err)
				}
				e.Set(name, val)
				return val, nil
			case carAtom.s == "defn":
				args := t.cdr.(*ConsCell)
				if args == Nil {
					return nil, fmt.Errorf("defn requires a function name")
				}
				name, ok := args.car.(Atom)
				if !ok {
					return nil, fmt.Errorf("defn name must be an atom")
				}
				args = args.cdr.(*ConsCell)
				if args == Nil {
					return nil, fmt.Errorf("defn requires an argument list")
				}
				fn := mkLambda(args, e)
				e.Set(name.s, fn)
				return Nil, nil
			case carAtom.s == "errors":
				return evErrors(t.cdr.(*ConsCell), e)
			case carAtom.s == "let":
				args := t.cdr.(*ConsCell)
				if args == Nil {
					return nil, fmt.Errorf("let requires a binding list")
				}
				bindings, ok := args.car.(*ConsCell)
				if !ok {
					return nil, fmt.Errorf("let bindings must be a list")
				}
				body := args.cdr.(*ConsCell)
				newEnv := mkEnv(e)
				for ; bindings != Nil; bindings = bindings.cdr.(*ConsCell) {
					binding, ok := bindings.car.(*ConsCell)
					if !ok {
						return nil, fmt.Errorf("a let binding must be a list")
					}
					name := binding.car.(Atom).s
					val, err := eval(binding.cdr.(*ConsCell).car, e)
					if err != nil {
						return nil, err
					}
					newEnv.Set(name, val)
				}
				exprs, err := evList(body, &newEnv)
				if err != nil {
					return nil, err
				}
				if len(exprs) == 0 {
					return Nil, nil
				}
				return exprs[len(exprs)-1], nil
			case carAtom.s == "lambda":
				return mkLambda(t.cdr.(*ConsCell), e), nil
			}
		}
		// functions / normal order of evaluation:
		evalCar, err := eval(t.car, e)
		if err != nil {
			return nil, err
		}
		evaledList, err := evList(t.cdr.(*ConsCell), e)
		if err != nil {
			return nil, err
		}
		return applyFn(evalCar, evaledList)
	default:
		panic(fmt.Sprintf("unknown type to eval: %T", t))
	}
}

func balancedParenPoints(tokens []lexutil.LexItem) (int, int, error) {
	level := 0
	start := 0
	for i, token := range tokens[start:] {
		switch token.Typ {
		case itemLeftParen:
			level++
		case itemRightParen:
			level--
			if level == 0 {
				return 0, i, nil
			}
		}
	}
	return 0, 0, fmt.Errorf("unbalanced parens")
}

func mkList(xs []Sexpr) *ConsCell {
	if len(xs) == 0 {
		return Nil
	}
	return Cons(xs[0], mkList(xs[1:]))
}

// parse returns a list of sexprs parsed from a list of tokens.
func parse(tokens []lexutil.LexItem) ([]Sexpr, error) {
	ret := []Sexpr{}
	i := 0
	for {
		if i >= len(tokens) {
			break
		}
		token := tokens[i]
		switch token.Typ {
		case itemNumber:
			ret = append(ret, Num(token.Val))
			i++
		case itemAtom:
			ret = append(ret, Atom{token.Val})
			i++
		case itemForwardQuote:
			i++ // skip ' token
			if i >= len(tokens) {
				return nil, fmt.Errorf("unexpected end of input")
			}
			var quoted Sexpr
			var delta int
			// quoted and delta depend on whether the quoted expression is
			// a list or an atom/num:
			if tokens[i].Typ != itemLeftParen {
				inner, err := parse(tokens[i : i+1])
				if err != nil {
					return nil, err
				}
				quoted = inner[0]
				delta = 1
			} else {
				start, end, err := balancedParenPoints(tokens[i:])
				if err != nil {
					return nil, err
				}
				inner, err := parse(tokens[i+start+1 : i+end])
				if err != nil {
					return nil, err
				}
				quoted = mkList(inner)
				delta = end - start + 1
			}
			i += delta
			quoteList := []Sexpr{Atom{"quote"}}
			quoteList = append(quoteList, quoted)
			ret = append(ret, mkList(quoteList))
		case itemLeftParen:
			start, end, err := balancedParenPoints(tokens[i:])
			if err != nil {
				return nil, err
			}
			inner, err := parse(tokens[i+start+1 : i+end])
			if err != nil {
				return nil, err
			}
			ret = append(ret, mkList(inner))
			i = i + end + 1
		case itemRightParen:
			return nil, fmt.Errorf("unexpected right paren")
		default:
			return nil, fmt.Errorf(token.Val)
		}
	}
	return ret, nil
}

func lexAndParse(s string) ([]Sexpr, error) {
	return parse(lexItems(s))
}
