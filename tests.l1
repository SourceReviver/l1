;; Unit tests in l1-proper

(test '(basic stuff
              cons
              car cdr
              len)
  (errors '(is not a function)
    (t))
  (errors '(is not a function)
    (1))
  (errors '(is not a function)
    (()))
  (test '(car and cdr)
    (is (= (car ()) ()))
    (is (= (cdr ()) ()))
    (is (= (cdr '(is not common lisp))
           '(not common lisp)))
    (is (= (car '(is not common lisp))
           'is))
    (is (= 1
           (car '(1 2 3))))
    (is (= '(2 3) (cdr '(1 2 3)))))

  (test '(len)
    (is (= 3 (len '(1 2 3))))
    (is (= 0 (len ())))
    (errors '(is not a list) (len 3)))

  (errors '(missing argument) (cons))
  (errors '(expects a single argument) (atom?))
  (errors '(missing argument) (car))
  (errors '(not a list) (car t))
  (errors '(missing argument) (cdr))
  (errors '(not a list) (cdr t))
  (is (= '(1 2 3 4) (cons 1 '(2 3 4))))
  (is (= '((1 2) 3 4) (cons (cons 1 (cons 2 ())) '(3 4))))
  (is (= '(()) (cons () ())))
  (is (= '(1 . 2) (cons 1 2)))
  (is (= '(1 2) (cons 1 '(2))))
  (is (= '((1 . 2)) (cons (cons 1 2) ())))
  (is (= 1 (car '(1 . 2))))
  (is (= 2 (cdr '(1 . 2))))
  (is (= '((1) . 2) (cons '(1) 2))))

(test '(types)
  (is (atom? (quote foo)))
  (is (not (atom? (quote (foo bar)))))
  (is (atom? (quote atom?)))
  (is (not (atom? atom?)))
  (is (not (number? 'a)))
  (is (number? 3))
  (is (not (list? 'a)))
  (is (list? ()))
  (is (list (range 3)))
  (is (not (atom? '(jack))))
  (is (atom? 'a)))

(test '(equality)
  (is (= t t))
  (is (= (not t) ()))
  (is (= (not ()) t))
  (is (= (cons t ()) '(t)))
  (is (= (cons (quote hello) (quote (world)))
         '(hello world)))
  (is (= (quote foo) 'foo))
  (is (= (quote 3) 3))
  (is (= (quote (1 2 3)) '(1 2 3)))
  (is (= '(1 2 3) '(1 2 3)))
  (is (= (quote ()) ()))

  (is (= (quote foo) (quote foo)))
  (is (= () ()))
  (is (not (= (quote foo) (quote bar))))
  ;; P.G.'s interpretation of McCarthy says this is (), but
  ;; it's simpler to have just one equality operator for now,
  ;; which works for numbers, lists and atoms:
  (is (not (= (quote foo) (quote (foo bar)))))
  (is (= (quote (foo bar)) (quote (foo bar))))
  (is (= 2 (+ 1 1)))
  (is (= 2 (+ 1 1) (- 3 1)))
  (is (not (= (quote (1 2 3)) ()))))

(test '(cond)
  (is (not (cond)))
  (is (not (cond (() 3))))
  (is (= 3 (cond (3 3))))
  (is (not (cond)))
  (is (= ()
         (cond (() 3)
               (() 4))))
  (is (= (cond (t 3)
               (t 4))
         3))

  (is (= t (cond (t t) ((-) t))))

  (errors '(requires a list of pairs) (cond ()))
  (errors '(requires a list of pairs) (cond (t)))
  (errors '(missing argument) (cond ((-) t)))
  (errors '(missing argument) (cond (t (-))))
  (errors '(missing argument) (cond (() t) ((-) t)))
  (errors '(missing argument) (cond (() t) (t (-)))))

(test '(lambdas)
  (is (= () ((lambda ()))))
  (is (= 333 ((lambda () 333))))
  (is (= 1 ((lambda (_) 1) '(stop ignoring me))))
  (is (= 2 ((lambda (x) (+ 1 x)) 1)))
  (is (= 1 ((lambda () 1 2 1))))
  (is (= 3 ((lambda () 1 2 3))))
  (errors '(division by zero) ((lambda ()
                                 (/ 1 0))))

  (errors '(division by zero) ((lambda ()
                                 1
                                 (/ 1 0))))
  (is (= 1 ((lambda (a b c d) d)
            4 3 2 1)))
  ;; rest args / n-ary lambdas:
  (is (= (list 2 3 4) ((lambda (a . d) d)
                       1 2 3 4)))
  (errors '(not enough arguments) ((lambda (a . d) d)))
  (errors '(not enough arguments) ((lambda (a b . d) d) 1))
  (errors '(not enough arguments) ((lambda (a b) d) 1))
  (errors '(too many arguments) ((lambda (a b) b) 1 2 3))

  (errors '(requires an argument list) (lambda 3))
  (errors '(argument list item is not an atom) (lambda (3)))
  (errors '(requires a rest argument) ((lambda (()))))
  (errors '(cannot bind or set t) ((lambda (t)) 2))

  ;; rest-only lambdas:
  (= 3 ((lambda (a . l) (len l)) 0 1 2 3))
  (= 0 ((lambda (a . l) (len l)) 'hi))
  (= 3 ((lambda (() . l) (len l)) 1 2 3))
  (= 0 ((lambda (() . l) (len l))))

  ;; named lambdas:
  (is (not ((lambda foo ()))))
  (is (= 3 ((lambda count (l)
              (cond (l (inc (count (cdr l))))
                    (t 0)))
            (range 3)))))

(test '(defn)
  (defn foo ())
  (is (= () (foo)))
  (defn foo (a))
  (is (= () (foo 1)))
  (defn foo (a) a)
  (is (= 1 (foo 1)))
  (errors '(name must be an atom) (defn (bazzy)))
  (errors '(requires a function name) (defn))
  (errors '(requires an argument list) (defn foo))

  ;; rest params:
  (defn wierd-len (() . l)
    (len l))
  (is (= 0 (wierd-len)))
  (is (= 5 (wierd-len 1 1 1 1 1)))
  (defn wierder-len (a . l) (len l))
  (errors '(not enough arguments) (wierder-len))
  (is (= 0 (wierder-len 1)))
  (is (= 1 (wierder-len 1 2)))
  (is (= 10 (wierder-len 1 1 2 3 4 5 6 7 8 9 10)))

  ;; doclists:
  (defn a () 3)
  (is (= 3 (a)))
  (is (not (doc a)))
  (errors '(missing argument) (doc))
  (errors '(expected function) (doc 3))
  (def b (lambda ()))
  (is (not (doc b)))
  (def bdoc (lambda () (doc (it floats))))
  (is (= '((it floats)) (doc bdoc)))
  (is (not (bdoc)))

  (defn a () (doc (do something)) 3)
  (is (= 3 (a)))
  (is (= '((do something)) (doc a)))

  (defn c ()  (doc (something 1)
                   (something 2)
                   (something 3)
                   (example (= 'c (c))))
    'c)
  (is (= 'c (c))))

(test '(split and fuse)
  (is (= '(1) (split 1)))
  (is (= '(-1) (split -1)))
  (is (= '(-3 2 1) (split -321)))
  (is (= '(a) (split (quote a))))
  (is (= '(g r e e n s p u n) (split 'greenspun)))
  (is (= '(8 3 8 1 0 2 0 5 0) (split (* 12345 67890))))
  (is (= 15 (len (split (* 99999 99999 99999)))))
  (errors '(expects a single argument)
    (split))
  (errors '(expects a single argument)
    (split 1 1))
  (errors '(expects an atom or a number)
    (split '(a b c)))

  (is (= '() (fuse ())))
  (is (= 'a (fuse (quote (a)))))
  (is (= 'aa (fuse (quote (aa)))))
  (is (= 'ab (fuse (quote (a b)))))
  (is (= 1 (fuse (quote (1)))))
  (is (= 12 (fuse (quote (1 2)))))
  (is (= 125 (+ 2 (fuse (quote (1 2 3))))))
  (is (= 1295807125987 (fuse (split 1295807125987))))
  (errors '(expects a single argument)
    (fuse)))

(test '(randomness)
  (is (= 1000 (len (randigits 1000))))
  (errors '(not enough arguments)
    (randigits))

  (is (= 1 (randchoice (list 1 1 1 1 1)))))

(test '(list function)
  (is (= '(1 2 3)
         (list 1 2 3)))
  (is (= '(1 2 3) (list 1 (+ 1 1) (+ 4 -1))))
  (is (= () (list))))

(test '(concat)
  (is (= () (concat)))
  (is (= () (concat ())))
  (is (= () (concat () ())))
  (is (= '(a b c d)
         (concat '(a b) '(c d))))
  (is (= '(a b c d e f) (concat '(a b) '(c d) '(e f)))))

(test '(reduce)
  (is (= 0 (reduce + ())))
  (is (= 1 (reduce * ())))
  (is (= 0 (reduce + '(0))))
  (is (= 0 (reduce + 0 ())))
  (is (= 1 (reduce + 0 (range 2))))
  (is (= 6 (reduce + 0 (range 4))))
  (is (= 362880 (reduce * 1 (split 123456789))))
  (is (= (range 10)
         (reduce concat (map list (range 10))))))

(test '(apply)
  (is (= 6 (apply + '(1 2 3))))
  (is (= 0 (apply + ())))
  (is (= 1 (apply + '(1))))
  (is (= 6 (apply * '(1 2 3))))
  (is (= 6 (apply * (split 123))))
  (is (= 362880 (apply * (split 123456789))))
  (is (= 1 (apply / (split 1111))))
  (is (= t (apply = (split 'ooooooooooooooooo))))
  (is (= () (apply = (split 'foo))))
  (is (= t (apply (lambda (x y) (= x y)) (split 11))))
  (is (= () (apply (lambda (x y z) (= x y z)) (split 121))))

  (is (= 12 (apply (lambda (x y z) (+ x y z))
                   (list (+ 1 1) (+ 2 2) (+ 3 3)))))

  (is (= 0 (apply + ())))
  (is (= 0 (apply + 0 ())))
  (is (= 10 (apply + 1 2 '(3 4))))
  (is (= 362880 (apply * (cdr (range 10)))))
  (is (= 499500 (apply + (range 1000))))
  (errors '(not enough arguments) (apply))
  (errors '(not enough arguments) (apply +))
  (errors '(too many arguments)
    (apply (lambda (x y) (= x y)) (split 123)))

  ;; FIXME: this BREAKS EVERYTHING!!!!
  ;; (apply concat (map list (range 10)))
  )

(test '(higher order functions)
  (is (zero? ((cond (t +)))))
  (is (= 6 ((car (cons + ())) 1 2 3)))
  (def a +)
  (is (= 2 (a 1 1))))

(test '(zero? pos? and neg?)
  (is (not (pos? 0)))
  (is (pos? 1))
  (is (neg? -1))
  (errors '(not enough arguments) (pos?))
  (errors '(too many arguments) (pos? 1 1))
  (errors '(is not a number) (pos? 'one)))

(test '(inequalities <= < > >=)
  (is (< 1 2))
  (is (< 1 2 3))
  (is (not (< 1 2 3 3)))
  (is (<= 1 2 3 3))
  (is (not (< 1 2 1)))
  (is (not (< 2 1)))
  (is (not (< 2 1 3)))
  (is (> 1))
  (is (> 3 2 1 0))
  (is (not (< 0 0)))
  (is (not (> 3 2 1 1)))
  (is (> 3 2 1 0))
  (is (>= 3 2 1 1))
  (errors '(is not a number) (< t 1))
  (errors '(is not a number) (< 1 t)))

(test '(arithmetic)
  (is (zero? 0))
  (is (not (zero? (quote zero))))
  (is (= 0))
  (is (= 0 0))
  (is (= 0 0 0))
  (is (not (= 0 0 1)))
  (is (= 1 (+ 1)))
  (is (= -1 (+ -1)))
  (is (= 0 (+ 0)))
  (is (= 2 (+ 1 1)))
  (is (= 3 (+ 1 2)))
  (is (= 7 (+ 1 1 2 3)))
  (is (= 0 (+)))
  (is (= (* 12349807213490872130987
            12349807213490872130987)
         152517738210391179737088822267441718485594169))
  (is (= 55 (+ 1 2 3 4 5 6 7 8 9 10)))
  (is (= 1000000000000000 (+ 999999999999999 1)))
  (is (= 1000000000000000 (+ 1 999999999999999)))
  (is (= 1 (+ (+ 1))))
  (is (= 21 (+ (+ 1 2 3) 4 5 6)))
  (is (= -1 (- 1)))
  (is (= 0 (- 1 1)))
  (is (= 31489071430987532109487513094875031984750983147
         31489071430987532109487513094875031984750983147))
  (is (= 0 (- 12349807213490872130987
              12349807213490872130987)))
  (is (= -9 (- (+ 1 2 3) 4 5 6)))
  (is (= 1 (*)))
  (is (= 1 (* 1 1)))
  (is (= 2432902008176640000
         (* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)))
  (is (= 1 (/ 1 1)))
  (is (= 2 (/ 4 2)))
  (is (= 0 (/ 1 2)))

  (is (= 1 (* 1 1 1 (*) (*) (*))))
  (is (= 3 (+ 1 1 1 (+) (+) (+))))

  (is (zero? (rem 1 1)))
  (is (zero? (rem 10 10)))
  (is (= 1 (rem 5 2)))

  (errors '(division by zero) (rem 1 0))
  (errors '(requires two arguments) (rem))
  (errors '(expected number) (rem t t))
  (errors '(expected number) (rem t 1))
  (errors '(expected number) (rem 1 t))
  (errors '(missing argument) (=))
  (errors '(missing argument) (-))
  (errors '(missing argument) (/))
  (errors '(division by zero) (/ 1 0))
  (errors '(expected number) (+ 0 (cond)))
  (errors '(expected number) (+ t 1))
  (errors '(expected number) (- t))
  (errors '(expected number) (- t 1))
  (errors '(expected number) (- 1 t))
  (errors '(expected number) (* t))
  (errors '(expected number) (/ t))
  (is (= 1 (/ 1)))
  (errors '(expected number) (/ 1 t)))

(test '(closures scope and shadowing)
  (def plus3-maker
       (lambda ()
         ((lambda (a)
            (lambda (x)
              (+ a x)))
          3)))
  (is (= 7 ((plus3-maker) 4)))
  (defn incrementer (n)
    (lambda (x)
      (+ x n)))
  (def inc (incrementer 1))
  (is (= 6 (inc 5)))
  (def add2 (incrementer 2))
  (is (= 7 (add2 5)))

  (is (= 0 (def x 0)))
  (zero? x)
  (is (zero? (cond ((= x 0) 0)
                   (t x))))
  (is (= 1 (def x 1)))
  (is (= 1 (cond ((= x 0) 0)
                 (t x))))

  (def a 1)
  (def b 2)
  (is (= 6 ((lambda (x) (+ x a b)) 3)))

  (defn f (x) (+ 1 x))
  (is (= 3 (f 2)))

  (defn f (x) (cond (x 3) (t 4)))
  (is (= 3
         (f t)
         (f 1)
         (f '(1 2 3))
         (f f)))
  (is (= 4 (f ())))

  (defn f (x)
    (cond ((= x 3) 1)
          (t (+ 1 (f 3)))))
  (is (= 1 (f 3)))
  (is (= 2 (f 4)))

  ;; This one found a tricky bug while figuring out envs / scope:
  (def f (lambda (x) (+ x (g (- x 1)))))
  (def g (lambda (x) 0))
  (is (= 1 (f 1)))

  (test '(shadowing)
    (def a 1)
    (def f (lambda (a) (+ a a)))
    (is (= 6 (f 3)))
    (def a 999)
    (is (= 4 (f 2)))))

(test '(slow fibonacci)
  (def fib
       (lambda (n)
         (cond ((zero? n) 0)
               ((= 1 n) 1)
               (t (+ (fib (- n 1))
                     (fib (- n 2)))))))
  (is (= 0 (fib 0)))
  (is (= 1 (fib 1)))
  (is (= 13 (fib 7)))
  (is (= 55 (fib 10)))
  (is (= 6765 (fib 20))))

(test '(factorial)
  (defn fact (n)
    (cond ((zero? n) 1)
          (t (* n (fact (- n 1))))))
  (is (= 30414093201713378043612608166064768844377641568960512000000000000
         (fact 50)))
  (is (= 2568 (len (split (fact 1000))))))

;; This case helped me (JJ) find a subtle math/pointer bug:
(test '(oddcase)
  (def f
       (lambda (x)
	 (cond ((= x 0) 0)
	       (t (+ x (f (- x 1)))))))
  (is (zero? (f 0)))
  (is (= 1 (f 1))))

(test '(let)
  (is (not (let ())))
  (is (= 2 (let ((_ 1))
             2)))
  (is (zero? (let ((_ 1))
               1
               2
               3
               0)))
  (is (zero? (let ((a 0))
               a)))
  (errors '(let bindings must be a list) (let 3))
  (errors '(a let binding must be a list)
    (let ((a 0)
          3)))
  (test '(shadowing inside let)
    (is (= 4
           (let ((a 1))
             (+ a (let ((a 2))
                    (+ a 1))))))))

(test '(version)
  (is (< 2 (len (version)))))

(test '(alpha / word stuff)
  (is (= 10 (len (randalpha 10))))
  (is (= 1000 (len (split (fuse (randalpha 1000))))))
  (is (= 'Capoeira (capitalize 'capoeira)))
  (is (= 'KARATE (upcase 'kaRatE)))
  (is (= 'break-dancing (downcase 'BREAK-dancing)))
  (is (= 'Nope. (period (capitalize 'nope))))
  (is (= 'Well, (comma (capitalize 'well))))
  (is (= 'bang! (bang 'bang)))
  (is (= '(You.) (tosentence '(you))))
  (is (= '(You hoo.) (tosentence '(you hoo))))
  (is (= '(Boo hoo hoo.) (tosentence '(boo hoo hoo))))
  (is (= '(Go away!) (exclaimed '(go away)))))

(test '(core / l1 functions)
  (is (= () (reverse ())))
  (is (= 'apogee (fuse (reverse (split 'eegopa)))))
  (is (= '(1 2 3) (concat '(1 2 3) ())))
  (is (= '(1 2 3 4 5 6) (concat '(1 2 3) '(4 5 6))))
  ;; FIXME: Make n-ary concat:
  ;; (is (= '(1 2 3 4 5 6) (concat '(1 2) '(3 4) '(5 6))))
  (is (= 1000 (len (range 1000))))
  (is (zero? (car (range 5))))
  (is (= 4 (last (range 5))))

  (is (= 'abc (fuse (take 3 (split 'abcdefg)))))
  (is (= (range 10) (take 10 (range 100))))
  (is (= (range 3) (take 10 (range 3))))
  (is (= (range 10) (drop 0 (range 10))))
  (is (= '(5 6 7 8 9) (drop 5 (range 10))))
  (is (= () (drop 1000 (range 10))))

  (is (= 1 (caar '((1 2) (3 4)))))

  (is (even? 2))
  (is (even? 2000))
  (is (odd? 3))
  (is (odd? 2001))
  (is ((complement odd?) 2))

  (is (= () (flatten '(()))))
  (is (= (split 'abcdefgh) (flatten '(a b (c d (e f) g h)))))

  (is (= 3 ((constantly 3))))
  (is (= 3 ((constantly 3) '(ignore me))))

  (is (= '(t t t t t))) (repeat 5 t)

  (is (= '(1 2 3 4 5)
         (map inc (range 5))))

  (is (= 1024 (** 2 10)))
  (is (= 10000000000 (** 10 10)))
  (is (= 18446744073709551616 (** 2 64)))

  (is (= '(0 2 4) (filter even? (range 5))))
  (is (= '(1 3))) (remove even? (range 5)))
