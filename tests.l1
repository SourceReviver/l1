;; Unit tests in l1-proper

(test '(basic stuff)
  (is (= t t))
  (is (= (not t) ()))
  (is (= (not ()) t))
  (errors '(is not a function)
    (t))
  (errors '(is not a function)
    (1))
  (errors '(is not a function)
    (()))
  (is (= (cons t ()) '(t)))
  (is (= (cons (quote hello) (quote (world)))
         '(hello world)))
  (is (= (quote foo) 'foo))
  (is (= (quote 3) 3))
  (is (= (quote (1 2 3)) '(1 2 3)))
  (is (= '(1 2 3) '(1 2 3)))
  (is (= (quote ()) ()))
  (is (= (car ()) ()))
  (is (= (cdr ()) ()))
  (is (= (cdr '(is not common lisp))
         '(not common lisp)))
  (is (= (car '(is not common lisp))
         'is))
  (is (= 3 (len '(1 2 3))))
  (is (= 0 (len ())))
  (errors '(is not a list) (len 3))
  (is (= 2 (+ 1 1)))
  (is (= 3 (+ 1 2)))
  (is (= 7 (+ 1 1 2 3)))
  (is (= 0 (+)))
  (is (= (* 12349807213490872130987
            12349807213490872130987)
         152517738210391179737088822267441718485594169))
  (is (= 0))
  (is (= 0 0))
  (is (= 0 0 0))
  (is (not (= 0 0 1)))
  (is (zero? 0))
  (is (not (zero? (quote zero)))))

(test '(cond)
  (is (not (cond)))
  (is (not (cond (() 3))))
  (is (= 3 (cond (3 3))))
  (is (not (cond)))
  (is (= ()
         (cond (() 3)
               (() 4))))
  (is (= (cond (t 3)
               (t 4))
         3))
  (errors '(missing argument)
    (cond ((-) t)))
  (errors '(missing argument)
    (cond (t (-))))
  (is (= t (cond (t t) ((-) t))))
  (errors '(missing argument)
    (cond (() t)
          ((-) t)))
  (errors '(missing argument)
    (cond (() t) (t (-)))))

(test '(split)
  (is (= '(1) (split 1)))
  (is (= '(-1) (split -1)))
  (is (= '(-3 2 1) (split -321)))
  (is (= '(a) (split (quote a))))
  (is (= '(g r e e n s p u n) (split 'greenspun)))
  (is (= '(8 3 8 1 0 2 0 5 0) (split (* 12345 67890))))
  (is (= 15 (len (split (* 99999 99999 99999)))))
  (errors '(expects a single argument)
    (split))
  (errors '(expects a single argument)
    (split 1 1))
  (errors '(expects an atom or a number)
    (split '(a b c))))

(test '(fuse)
  (is (= '() (fuse ())))
  (is (= 'a (fuse (quote (a)))))
  (is (= 'aa (fuse (quote (aa)))))
  (is (= 'ab (fuse (quote (a b)))))
  (is (= 1 (fuse (quote (1)))))
  (is (= 12 (fuse (quote (1 2)))))
  (is (= 125 (+ 2 (fuse (quote (1 2 3))))))
  (is (= 1295807125987 (fuse (split 1295807125987))))
  (errors '(expects a single argument)
    (fuse)))

(test '(randigits)
  (is (= 1000 (len (randigits 1000))))
  (errors '(expects a single argument)
    (randigits)))

(test '(apply)
  (is (= 6 (apply + '(1 2 3))))
  (is (= 0 (apply + ())))
  (is (= 1 (apply + '(1))))
  (is (= 6 (apply * '(1 2 3))))
  (is (= 6 (apply * (split 123))))
  (is (= 362880 (apply * (split 123456789))))
  (is (= 1 (apply / (split 1111))))
  (is (= t (apply = (split 'ooooooooooooooooo))))
  (is (= () (apply = (split 'foo))))
  (is (= t (apply (lambda (x y) (= x y)) (split 11))))
  (is (= () (apply (lambda (x y z) (= x y z)) (split 121))))
  (errors '(expects exactly two arguments)
    (apply))
  (errors '(expects exactly two arguments)
    (apply +))
  (errors '(wrong number of args)
    (apply (lambda (x y) (= x y)) (split 123))))

(test '(higher order functions)
  (is (zero? ((cond (t +)))))
  (is (= 6 ((car (cons + ())) 1 2 3)))
  (def a +)
  (is (= 2 (a 1 1))))

(test '(zero? pos? and neg?)
  (is (not (pos? 0)))
  (is (pos? 1))
  (is (neg? -1))
  (errors '(expects a single argument) (pos?))
  (errors '(expects a single argument) (pos? 1 1))
  (errors '(is not a number) (pos? 'one)))

(test '(inequalities <= < > >=)
  (is (< 1 2))
  (is (< 1 2 3))
  (is (not (< 1 2 3 3)))
  (is (<= 1 2 3 3))
  (is (not (< 1 2 1)))
  (is (not (< 2 1)))
  (is (not (< 2 1 3)))
  (is (> 1))
  (is (> 3 2 1 0))
  (is (not (< 0 0)))
  (is (not (> 3 2 1 1)))
  (is (> 3 2 1 0))
  (is (>= 3 2 1 1))
  (errors '(is not a number) (< t 1))
  (errors '(is not a number) (< 1 t)))

(test '(arithmetic)
  (is (= 1 (+ 1)))
  (is (= -1 (+ -1)))
  (is (= 0 (+ 0)))
  (is (= 55 (+ 1 2 3 4 5 6 7 8 9 10)))
  (is (= 1000000000000000 (+ 999999999999999 1)))
  (is (= 1000000000000000 (+ 1 999999999999999)))
  (is (= 1 (+ (+ 1))))
  (is (= 21 (+ (+ 1 2 3) 4 5 6)))
  (is (= -1 (- 1)))
  (is (= 0 (- 1 1)))
  (is (= 31489071430987532109487513094875031984750983147
         31489071430987532109487513094875031984750983147))
  (is (= 0 (- 12349807213490872130987
              12349807213490872130987)))
  (is (= -9 (- (+ 1 2 3) 4 5 6)))
  (is (= 1 (*)))
  (is (= 1 (* 1 1)))
  (is (= 2432902008176640000
         (* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)))
  (is (= 1 (/ 1 1))))

(test '(closures scope and shadowing)
  (def plus3-maker
       (lambda ()
         ((lambda (a)
            (lambda (x)
              (+ a x)))
          3)))
  (is (= 7 ((plus3-maker) 4)))
  (def incrementer
       (lambda (n)
         (lambda (x)
           (+ x n))))
  (def inc (incrementer 1))
  (is (= 6 (inc 5)))
  (def add2 (incrementer 2))
  (is (= 7 (add2 5)))

  (test '(shadowing)
    (def a 1)
    (def f (lambda (a) (+ a a)))
    (is (= 6 (f 3)))
    (def a 999)
    (is (= 4 (f 2)))))

(test '(slow fibonacci)
  (def fib
       (lambda (n)
         (cond ((zero? n) 0)
               ((= 1 n) 1)
               (t (+ (fib (- n 1))
                     (fib (- n 2)))))))
  (is (= 0 (fib 0)))
  (is (= 1 (fib 1)))
  (is (= 13 (fib 7)))
  (is (= 55 (fib 10)))
  (is (= 6765 (fib 20))))

(test '(factorial)
  (def fact
       (lambda (n)
         (cond ((zero? n) 1)
               (t (* n (fact (- n 1)))))))
  (is (= 30414093201713378043612608166064768844377641568960512000000000000
         (fact 50)))
  (is (= 2568 (len (split (fact 1000))))))

;; This case helped me (JJ) find a subtle math/pointer bug:
(test '(oddcase)
  (def f
       (lambda (x)
	 (cond ((= x 0) 0)
	       (t (+ x (f (- x 1)))))))
  (is (zero? (f 0)))
  (is (= 1 (f 1))))
