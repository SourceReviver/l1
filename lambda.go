package main

import (
	"fmt"
	"strings"
)

type lambdaFn struct {
	args []string
	body *ConsCell
	env  *env
}

func mkLambda(cdr *ConsCell, e *env) *lambdaFn {
	args := []string{}
	argList := cdr.car.(*ConsCell)
	for ; argList != Nil; argList = argList.cdr.(*ConsCell) {
		args = append(args, argList.car.(Atom).s)
	}
	return &lambdaFn{args, cdr.cdr.(*ConsCell), e}
}

func (f *lambdaFn) String() string {
	return fmt.Sprintf("<lambda(%s)>", strings.Join(f.args, " "))
}

func (f *lambdaFn) Eval(e *env) (Sexpr, error) {
	return f, nil
}

func (f *lambdaFn) Equal(o Sexpr) bool {
	return false
}

// evLambda evaluates f in a new environment generated by adding bindings for each
// of the args to the current environment:
func (f *lambdaFn) evLambda(args []Sexpr) (Sexpr, error) {
	newEnv := mkEnv(f.env)
	if len(f.args) != len(args) {
		return nil, fmt.Errorf("wrong number of args: %d != %d", len(f.args), len(args))
	}
	for i, arg := range f.args {
		newEnv.Set(arg, args[i])
	}
	if f.body == Nil {
		return Nil, nil
	}
	// For the moment, only evaluate the first expression:
	return f.body.car.Eval(&newEnv)
}
