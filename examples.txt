$ l1
> (quote foo)
foo
> 'foo
foo
> '123
123
> (quote (the (ten (laws (of (greenspun))))))
(the (ten (laws (of (greenspun)))))
> ((lambda (x . xs) (list x xs)) 1 2 3 4)
(1 (2 3 4))
> (help)
l1 - a Lisp interpreter.

               Type        
               ---        
                S - special form
                M - macro
                N - native (Go) function
                F - Lisp function

          Name Type Arity  Description
          ---- ---  ----  -----------
             *  N    0+  Multiply 0 or more numbers
            **  F    2   Exponentiation operator
             +  N    0+  Add 0 or more numbers
             -  N    1+  Subtract 0 or more numbers from the first argument
             /  N    2+  Divide the first argument by the rest
             <  N    1+  Return t if the arguments are in strictly increasing order, () otherwise
            <=  N    1+  Return t if the arguments are in increasing (or qual) order, () otherwise
             =  N    1+  Return t if the arguments are equal, () otherwise
             >  N    1+  Return t if the arguments are in strictly decreasing order, () otherwise
            >=  N    1+  Return t if the arguments are in decreasing (or equal) order, () otherwise
           and  S    0+  Boolean and
         apply  N    2   Apply a function to a list of arguments
         atom?  N    1   Return t if the argument is an atom, () otherwise
          bang  F    1   Add an exclamation point at end of atom
          body  N    1   Return the body of a lambda function
       butlast  F    1   Return everything but the last element
          caar  F    1   First element of the first element of a list of lists
    capitalize  F    1   Return the atom argument, capitalized
           car  N    1   Return the first element of a list
           cdr  N    1   Return a list with the first element removed
         colon  F    1   Add a colon at end of atom
         comma  F    1   Add a comma at end of atom
       comment  M    0+  Ignore the expressions in the block
    complement  F    1   Return the logical complement of the supplied function
        concat  F    0+  Concatenenate any number of lists
          cond  S    0+  Fundamental branching construct
          cons  N    2   Add an element to the front of a (possibly empty) list
    constantly  F    1   Given a value, return a function which always returns that value
           dec  F    1   Return the supplied integer argument, minus one
           def  S    2   Set a value
      defmacro  S    2+  Create and name a macro
          defn  S    2+  Create and name a function
           doc  N    1   Return the doclist for a function
       dotimes  M    1+  Execute body for each value in a list
      downcase  N    1   Return a new atom with all characters in lower case
          drop  F    2   Drop n items from a list, then return the rest
         error  S    1   Raise an error
        errors  S    1+  Error checking (for tests)
         even?  F    1   Return true if the supplied integer argument is even
     exclaimed  F    1   Return l as a sentence... emphasized!
        filter  F    2   Keep only values for which function f is true
       flatten  F    1   Return a (possibly nested) list, flattened
       foreach  M    2+  Execute body for each value in a list
         forms  N    0   Return available operators, as a list
          fuse  N    1   Fuse a list of numbers or atoms into a single atom
          help  N    0   Print this message
      identity  F    1   Return the argument
            if  M    3   Simple conditional with two branches
        if-not  M    3   Simple (inverted) conditional with two branches
           inc  F    1   Return the supplied integer argument, plus one
            is  M    1   Assert a condition is truthy, or show failing code
          juxt  F    0+  Create a function which combines multiple operations into a single list of results
        lambda  S    1+  Create a function
          last  F    1   Return the last item in a list
           len  N    1   Return the length of a list
           let  S    1+  Create a local scope with bindings
          list  N    0+  Return a list of the given arguments
         list*  F    0+  Create a list by consing everything but the last arg onto the last
         list?  N    1   Return t if the argument is a list, () otherwise
          loop  S    1+  Loop forever
 macroexpand-1  N    1   Expand a macro
           map  F    2   Apply the supplied function to every element in the supplied list
        mapcat  F    2   Map a function onto a list and concatenate results
          neg?  F    1   Return true iff the supplied integer argument is less than zero
           not  N    1   Return t if the argument is nil, () otherwise
           nth  F    2   Find the nth value of a list, starting from zero
       number?  N    1   Return true if the argument is a number, else ()
          odd?  F    1   Return true if the supplied integer argument is odd
            or  S    0+  Boolean or
        period  F    1   Add a period at end of atom
          pos?  F    1   Return true iff the supplied integer argument is greater than zero
         print  N    0+  Print the arguments
        printl  N    1   Print a list argument, without parentheses
       println  N    0+  Print the arguments and a newline
         progn  M    0+  Execute multiple statements, returning the last
     punctuate  F    2   Return x capitalized, with punctuation determined by the supplied function
punctuate-atom  F    2   Add a punctuation mark at end of atom
         quote  S    1   Quote an expression
     randalpha  F    1   Return a list of random (English/Latin/unaccented) lower-case alphabetic characters
    randchoice  F    1   Return an element at random from the supplied list
     randigits  F    1   Return a random integer between 0 and the argument minus 1
       randint  N    1   Return a random integer between 0 and the argument minus 1
         range  F    1   List of integers from 0 to n
      readlist  N    0   Read a list from stdin
        reduce  F    2+  Successively apply a function against a list of arguments
           rem  N    2   Return remainder when second arg divides first
        remove  F    2   Keep only values for which function f is false / the empty list
        repeat  F    2   Return a list of length n whose elements are all x
    repeatedly  F    2   Return a list of length n whose elements are made from calling f repeatedly
       reverse  F    1   Reverse a list
  screen-clear  N    0   Clear the screen
    screen-end  N    0   Stop screen for text UIs, return to console mode
screen-get-key  N    0   Return a keystroke as an atom
   screen-size  N    0   Return the screen size (width, height)
  screen-start  N    0   Start screen for text UIs
  screen-write  N    3   Write a string to the screen
       shuffle  N    1   Return a (quickly!) shuffled list
         sleep  N    1   Sleep for the given number of milliseconds
          some  F    2   Return f applied to first element for which that result is truthy, else ()
         split  N    1   Split an atom or number into a list of single-digit numbers or single-character atoms
  syntax-quote  S    1   Syntax-quote an expression
          take  F    2   Take up to n items from the supplied list
          test  N    0+  Establish a testing block (return last expression)
    tosentence  F    1   Return l as a sentence... capitalized, with a period at the end
         true?  F    1   Return t if the argument is t
        upcase  N    1   Return the uppercase version of the given atom
       version  N    0   Return the version of the interpreter
          when  M    2   Simple conditional with single branch
      when-not  M    2   Complement of the when macro
   with-screen  M    0+  Prepare for and clean up after screen operations
         zero?  F    1   Return true iff the supplied argument is zero
> ^D
$
