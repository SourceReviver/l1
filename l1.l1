;; pi x 10**100:
(def pi100 (fuse '(31415926535897932384626433832795028
                   84197169399375105820974944592307816
                   406286208998628034825342117067)))

(defn identity (x)
  (doc (return the argument))
  x)

(defmacro if (condition then else)
  (doc (simple conditional with two branches))
  `(cond (~condition ~then)
         (t ~else)))

(defmacro if-not (condition then else)
  (doc (simple (inverted) conditional with two branches))
  `(cond ((not ~condition) ~then)
         (t ~else)))

(defmacro comment (() . body)
  (doc (ignore the expressions in the block)))

(defmacro when (condition then)
  (doc (simple conditional with single branch))
  `(cond (~condition ~then)))

(defmacro when-not (condition then)
  (doc (complement of the when macro))
  `(cond ((not ~condition) ~then)))

(defmacro progn (() . body)
  (doc (execute multiple statements, returning the last))
  `(let () ~@body))

(defmacro foreach (x xs . body)
  (doc (execute body for each value in a list))
  `(progn
     (map (lambda (~x)
            ~@body)
          ~xs)
     ()))

(defmacro dotimes (n . body)
  (doc (execute body for each value in a list))
  `(progn
     (map (lambda (_)
            ~@body)
          (range ~n))
     ()))

(defn reduce (f x . args)
  (doc (successively apply a function against a list of arguments))
  (let ((inner (lambda inner (f acc l)
                 (if (not l)
                   acc
                   (inner f
                          (f acc (car l))
                          (cdr l))))))
    (cond ((not args)        ;; no accumulator given
           (if (not x)
             (f)
             (inner f (car x) (cdr x))))
          ((= (len args) 1)  ;; x is the accumulator
           (inner f x (car args)))
          (t
           (error '(reduce needs at least two arguments))))))

(defn concat (() . lists)
  (doc (concatenenate any number of lists))
  (let ((concat2 (lambda concat2 (a b)
                   (if (not a)
                     b
                     (cons (car a)
                           (concat2 (cdr a) b))))))
    (when lists
      (reduce concat2 lists))))

(defn reverse (l)
  (doc (reverse a list)
       (example (= '(c b a) (reverse '(a b c)))))
  (when l
    (concat (reverse (cdr l))
            (cons (car l) ()))))

(defn zero? (n)
  (doc (return true iff the supplied argument is zero))
  (= n 0))

(defn neg? (n)
  (doc (return true iff the supplied integer argument is less than zero))
  (< n 0))

(defn pos? (n)
  (doc (return true iff the supplied integer argument is greater than zero))
  (< 0 n))

(defn inc (n)
  (doc (return the supplied integer argument, plus one))
  (+ n 1))

(defn dec (n)
  (doc (return the supplied integer argument, minus one))
  (- n 1))

(defn range (n)
  (doc (list of integers from 0 to n))
  (let ((inner (lambda inner (n)
                 (if (= 1 n)
                   (cons (dec n) ())
                   (cons (dec n) (inner (dec n)))))))
    (reverse (inner n))))

;; FIXME: Should error when l is ()!
(defn nth (n l)
  (doc (find the nth value of a list, starting from zero))
  (when l
    (if (zero? n)
      (car l)
      (nth (dec n) (cdr l)))))

(defn last (l)
  (doc (return the last item in a list))
  (let ((c (cdr l)))
    (if-not c
      (car l)
      (last c))))

(defn take (n l)
  (doc (take up to n items from the supplied list))
  (cond ((zero? n) ())
        ((not l) ())
        (t (cons (car l) (take (dec n) (cdr l))))))

(defn drop (n l)
  (doc (drop n items from a list, then return the rest))
  (cond ((zero? n) l)
        ((not l) ())
        (t (drop (dec n)
                 (cdr l)))))

(defn caar (l)
  (doc (first element of the first element of a list of lists))
  (car (car l)))

(defn complement (f)
  (doc (return the logical complement of the supplied function))
  ;; FIXME: n-ary? Need to fix `apply` to work w/ rest arguments.
  (lambda (x)
    (not (f x))))

(defn even? (n)
  (doc (return true if the supplied integer argument is even))
  (zero? (rem n 2)))

(defn odd? (n)
  (doc (return true if the supplied integer argument is odd))
  (not (even? n)))

(defn flatten (l)
  (doc (return a (possibly nested) list, flattened))
  (cond ((not l) ())
        ((list? l)
         (concat (flatten (car l))
                 (flatten (cdr l))))
        (t (list l))))

(defn constantly (x)
  (doc (given a value, return a function which always returns that value))
  (lambda (() . _)
    x))

(defn repeat (n x)
  (doc (return a list of length n whose elements are all x))
  (when-not (zero? n)
    (cons x (repeat (dec n) x))))

(defn repeatedly (n f)
  (doc (return a list of length n whose elements are made from calling f repeatedly))
  (when-not (zero? n)
    (cons (f) (repeatedly (dec n) f))))

(defn map (f l)
  (doc (apply the supplied function to every element in the supplied list))
  (when l
    (cons (f (car l))
          (map f (cdr l)))))

(defn mapcat (f l)
  (doc (map a function onto a list and concatenate results))
  (reduce concat (map f l)))

(defn filter (f l)
  (doc (keep only values for which function f is true))
  (cond ((not l) ())
        ((f (car l)) (cons (car l)
                           (filter f (cdr l))))
        (t (filter f (cdr l)))))

(defn remove (f l)
  (doc (keep only values for which function f is false / the empty list))
  (filter (complement f) l))

(defn ** (n m)
  (doc (exponentiation operator))
  (apply * (repeat m n)))

(defn capitalize (a)
  (doc (return the atom argument, capitalized))
  (let ((s (split a)))
    (fuse (concat (map upcase (take 1 s))
                  (drop 1 s)))))

(defn randigits (n)
  (doc (return a random integer between 0 and the argument minus 1))
  (repeatedly n
              (lambda () (randint 10))))

(defn randchoice (l)
  (doc (return an element at random from the supplied list))
  (nth (randint (len l)) l))

(defn randalpha (n)
  (doc (return a list of random (English/Latin/unaccented) alphabetic characters))
  (repeatedly n
              (lambda ()
                (randchoice (split 'abcdefghijklmnopqrstuvwxyz)))))

(defn butlast (l)
  (doc (return everything but the last element))
  (take (dec (len l)) l))

(defn punctuate (f x)
  (doc (return x capitalized, with punctuation determined by the supplied function))
  (cond ((not x) x)
        ((= (len x) 1) (list (capitalize (f (car x)))))
        (t (cons (capitalize (car x))
                 (concat (cdr (butlast x))
                         (list (f (last x))))))))

(defn tosentence (l)
  (doc (return l as a sentence... capitalized, with a period at the end))
  (punctuate period l))

(defn exclaimed (l)
  (doc (return l as a sentence... emphasized!))
  (punctuate bang l))

(defn list* (() . args)
  (doc (create a list by consing everything but the last arg onto the last))
  (when args
    (let ((endl (last args))
          (other (butlast args)))
      (concat other endl))))

(defmacro with-screen (() . body)
  (doc (prepare for and clean up after screen operations))
  `(progn
     (screen-start)
     (let ((result
            (progn ~@body)))
       (screen-end)
       result)))

(defn some (f l)
  (doc (return f applied to first element for which that result is truthy, else ()))
  (when l
    (let ((result (f (car l))))
      (if result
        result
        (some f (cdr l))))))

(defn punctuate-atom (a mark)
  (doc (add a punctuation mark at end of atom))
  (let ((l (split a)))
    (fuse (concat l (list mark)))))

(defn bang (a)
  (doc (add an exclamation point at end of atom))
  (punctuate-atom a BANG))

(defn comma (a)
  (doc (add a comma at end of atom))
  (punctuate-atom a COMMA))

(defn period (a)
  (doc (add a period at end of atom))
  (punctuate-atom a PERIOD))

(defn colon (a)
  (doc (add a colon at end of atom))
  (punctuate-atom a COLON))

(defmacro is (expr)
  (doc (assert a condition is truthy, or show failing code))
  `(when-not ~expr
     (error '(assertion ~(fuse (list 'failed COLON)) ~expr))))
