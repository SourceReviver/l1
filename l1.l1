;; pi x 10**100:
(def pi100 (fuse '(31415926535897932384626433832795028
                   84197169399375105820974944592307816
                   406286208998628034825342117067)))

(defn append (a b)
  (doc (append two lists)
       (example (= '(1 2 3 4) (append '(1 2) '(3 4)))))
  (cond ((not a) b)
        (t (cons (car a)
                 (append (cdr a) b)))))

(defn reverse (l)
  (doc (reverse a list)
       (example (= '(c b a) (reverse '(a b c)))))
  (cond ((not l) ())
        (t (append (reverse (cdr l))
                   (cons (car l) ())))))

(defn zero? (n) (= n 0))
(defn neg? (n) (< n 0))
(defn pos? (n) (< 0 n))

(defn dotimes (n f)
  (cond ((zero? n) ())
        (t (let () (f) (dotimes (- n 1) f)))))

(defn inc (n) (+ n 1))

(defn dec (n) (- n 1))

(defn range-inner (n)
  (cond ((= 1 n) (cons (dec n) ()))
        (t (cons (dec n) (range-inner (dec n))))))

(defn range (n)
  (reverse (range-inner n)))

(defn count (l)
  (cond ((not l) 0)
        (t (inc (len (cdr l))))))

(defn nth (n l)
  (cond ((zero? n) (car l))
        (t (nth (dec n) (cdr l)))))

(defn last (l)
  (let ((len_ (len l)))
    (nth (dec len_) l)))

(defn take (n l)
  (cond ((zero? n) ())
        ((not l) ())
        (t (cons (car l) (take (dec n) (cdr l))))))

(defn drop (n l)
  (cond ((zero? n) l)
        ((not l) ())
        (t (drop (dec n)
                 (cdr l)))))

(defn caar (l) (car (car l)))

(defn complement (f)
  ;; FIXME: n-ary? Need to fix `apply` to work w/ rest arguments.
  (lambda (x)
    (not (f x))))

(defn even? (n) (zero? (rem n 2)))
(def odd? (complement even?))

(defn flatten (l)
  (cond ((not l) ())
        ((list? l)
         (append (flatten (car l))
                 (flatten (cdr l))))
        (t (list l))))

(defn constantly (x)
  (lambda (() . _)
    x))

(defn repeat (n x)
  (cond ((zero? n) ())
        (t (cons x (repeat (dec n) x)))))

(defn map (f l)
  (cond ((not l) ())
        (t (cons (f (car l))
                 (map f (cdr l))))))

(defn filter (f l)
  (cond ((not l) ())
        ((f (car l)) (cons (car l)
                           (filter f (cdr l))))
        (t (filter f (cdr l)))))

(defn remove (f l) (filter (complement f) l))

(defn ** (n m) (apply * (repeat m n)))
