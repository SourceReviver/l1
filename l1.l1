;; pi x 10**100:
(def pi100 (fuse '(31415926535897932384626433832795028
                   84197169399375105820974944592307816
                   406286208998628034825342117067)))

(defn concat (a b)
  (doc (concatenate two lists)
       (example (= '(1 2 3 4) (concat '(1 2) '(3 4)))))
  (cond ((not a) b)
        (t (cons (car a)
                 (concat (cdr a) b)))))

(defn reverse (l)
  (doc (reverse a list)
       (example (= '(c b a) (reverse '(a b c)))))
  (cond ((not l) ())
        (t (concat (reverse (cdr l))
                   (cons (car l) ())))))

(defn zero? (n)
  (doc (return true iff the supplied argument is zero))
  (= n 0))

(defn neg? (n)
  (doc (return true iff the supplied integer argument is less than zero))
  (< n 0))

(defn pos? (n)
  (doc (return true iff the supplied integer argument is greater than zero))
  (< 0 n))

(defn dotimes (n f)
  (doc (run the supplied function n times))
  (cond ((zero? n) ())
        (t (let ()
             (f)
             (dotimes (- n 1) f)))))

(defn inc (n)
  (doc (return the supplied integer argument, plus one))
  (+ n 1))

(defn dec (n)
  (doc (return the supplied integer argument, minus one))
  (- n 1))

(defn __range (n)
  (doc (deprecated, used internally))
  (cond ((= 1 n) (cons (dec n) ()))
        (t (cons (dec n) (__range (dec n))))))

(defn range (n)
  (doc (list of integers from 0 to n))
  (reverse (__range n)))

(defn nth (n l)
  (doc (find the nth value of a list, starting from zero))
  (cond ((zero? n) (car l))
        (t (nth (dec n) (cdr l)))))

(defn last (l)
  (doc (return the last item in a list))
  (let ((len_ (len l)))
    (nth (dec len_) l)))

(defn take (n l)
  (doc (take up to n items from the supplied list))
  (cond ((zero? n) ())
        ((not l) ())
        (t (cons (car l) (take (dec n) (cdr l))))))

(defn drop (n l)
  (doc (drop n items from a list, then return the rest))
  (cond ((zero? n) l)
        ((not l) ())
        (t (drop (dec n)
                 (cdr l)))))

(defn caar (l)
  (doc (first element of the first element of a list of lists))
  (car (car l)))

(defn complement (f)
  (doc (return the logical complement of the supplied function))
  ;; FIXME: n-ary? Need to fix `apply` to work w/ rest arguments.
  (lambda (x)
    (not (f x))))

(defn even? (n)
  (doc (return true if the supplied integer argument is even))
  (zero? (rem n 2)))

(defn odd? (n)
  (doc (return true if the supplied integer argument is odd))
  (not (even? n)))

(defn flatten (l)
  (doc (return a (possibly nested) list, flattened))
  (cond ((not l) ())
        ((list? l)
         (concat (flatten (car l))
                 (flatten (cdr l))))
        (t (list l))))

(defn constantly (x)
  (doc (given a value, return a function which always returns that value))
  (lambda (() . _)
    x))

(defn repeat (n x)
  (doc (return a list of length n whose elements are all x))
  (cond ((zero? n) ())
        (t (cons x (repeat (dec n) x)))))

(defn map (f l)
  (doc (apply the supplied function to every element in the supplied list))
  (cond ((not l) ())
        (t (cons (f (car l))
                 (map f (cdr l))))))

(defn filter (f l)
  (doc (keep only values for which function f is true))
  (cond ((not l) ())
        ((f (car l)) (cons (car l)
                           (filter f (cdr l))))
        (t (filter f (cdr l)))))

(defn remove (f l)
  (doc (keep only values for which function f is false / the empty list))
  (filter (complement f) l))

(defn ** (n m)
  (doc (exponentiation operator))
  (apply * (repeat m n)))
