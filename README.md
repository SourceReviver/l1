# l1

<img src="/l1.jpg" width="400">

![build](https://github.com/eigenhombre/l1/actions/workflows/build.yml/badge.svg)

`l1` is a small interpreted [Lisp 1](https://en.wikipedia.org/wiki/Common_Lisp#The_function_namespace) written in Go.  Emphasizing simplicity
of data types (atoms, arbitrarily large integers, and lists) and start-up speed,
it aims to be a playground for future language experiments.

| l1 has                                    | doesn't have | will have                 | might get                            |
|-------------------------------------------|:------------:|:-------------------------:|:------------------------------------:|
| ints (large)                              | keywords     | macros                    | curses                               |
| comments (;; ....)                        | maps         | syntax quote              | graphics                             |
| atoms                                     | strings      | REPL / editor integration | subprocess / shells                  |
| lists                                     | namespaces   | let (as a macro)          | big floats                           |
| 4 special forms: cond, def, lambda, quote | exceptions   | defun/defn (as a macro)   | rational numbers                     |
| 16 built-in functions                     | loops        |                           | tail call optimization               |
| recursion                                 |              |                           | `error` equivalent                   |
| closures                                  |              |                           | byte code compilation/interpretation |
|                                           |              |                           | reader macros (`, ', ...)            |

# Usage / Examples

You should have Go installed and configured.  At some later point, pre-built
artifacts for various architectures may be available here.

## Installing Using the `go` Tool

    go install github.com/eigenhombre/l1@latest

## Building from Source

Check out this repo and `cd` to it. Then,

    go test
    go build
    go install

Extra testing and build infrastructure for this project relies on GitHub Actions, Docker, and Make.  Please look at the `Dockerfile` and `Makefile` for more information.

## Usage

To execute a file:

    $ l1 <file.l1>

Example (using a file in this project):

    $ cat fact.l1
    ;; Return the factorial of `n`:
    (def fact
         (lambda (n)
           (cond ((= 0 n) 1)
                 (t (* n (fact (- n 1)))))))

    (print (fact 100))
    $ time l1 fact.l1
    933262154439441526816992388562667004907159682643816214685929638
    952175999932299156089414639761565182862536979208272237582511852
    10916864000000000000000000000000

    real	0m0.008s
    user	0m0.004s
    sys	0m0.004s

## Example REPL Session

These were copied directly from the unit test output; `eval_test.go` has more examples.
<!-- The following examples are autogenerated, do not change by hand! -->
<!-- BEGIN EXAMPLES -->

    $ l1
    > ()  ;; Nil by any other name, would still smell as sweet...
    ()
    > (quote foo)
    foo
    > 'foo
    foo
    > '123
    123
    > (quote (the (ten (laws (of (greenspun))))))
    (the (ten (laws (of (greenspun)))))
    > (= (quote foo) (quote foo))
    t
    > (= (quote foo) (quote bar))
    ()
    > (= (quote foo) (quote (foo bar)))
    ()
    > (atom (quote (foo bar)))
    ()
    > (atom (quote atom))
    t
    > (cond (() 1) (2 3))
    3
    > (car '(1 2 3))
    1
    > (cdr '(1 2 3))
    (2 3)
    > (cons 1 '(2 3 4))
    (1 2 3 4)
    > (def a 6)
    6
    > (def b 7)
    7
    > (+ a b)
    13
    > ((lambda ()))
    ()
    > ((lambda (x) (+ 1 x)) 1)
    2
    > (def fact (lambda (n) (cond ((= 0 n) 1) (t (* n (fact (- n 1)))))))
    <lambda(n)>
    > (fact 50)
    30414093201713378043612608166064768844377641568960512000000000000
    > (len (split (fact 1000)))
    2568
    > (def fib (lambda (n) (cond ((= 0 n) 0) ((= 1 n) 1) (t (+ (fib (- n 1)) (fib (- n 2)))))))
    <lambda(n)>
    > (fib 0)
    0
    > (fib 1)
    1
    > (fib 7)
    13
    > (fib 10)
    55
    > (fib 20)
    6765
    > (def a 1)
    1
    > (def f (lambda () (def a 2) a))
    <lambda()>
    > (f)
    2
    > a
    1
    > (def incrementer (lambda (n) (lambda (x) (+ x n))))
    <lambda(n)>
    > (def inc (incrementer 1))
    <lambda(x)>
    > (inc 5)
    6
    > (def add2 (incrementer 2))
    <lambda(x)>
    > (add2 5)
    7
    > (errors '(assertion failed) (is ()))
    ()
    > (errors '(division by zero) (/ 1 0))
    ()
    > (test '(divide by zero) (errors '(zero) (/ 1 0)))
    ()
    > (help)
    Builtins and Special Forms:
          Name  Arity    Description
             *    0+     Multiply 0 or more numbers
             +    0+     Add 0 or more numbers
             -    1+     Subtract 0 or more numbers from the first argument
             /    2+     Divide the first argument by the rest
             <    1+     Return t if the arguments are in strictly increasing order, () otherwise
            <=    1+     Return t if the arguments are in increasing (or qual) order, () otherwise
             =    1+     Return t if the arguments are equal, () otherwise
             >    1+     Return t if the arguments are in strictly decreasing order, () otherwise
            >=    1+     Return t if the arguments are in decreasing (or equal) order, () otherwise
         apply    2      Apply a function to a list of arguments
          atom    1      Return true if the argument is an atom, false otherwise
           car    1      Return the first element of a list
           cdr    1      Return a list with the first element removed
          cond    0+     SPECIAL FORM: Conditional branching
          cons    2      Add an element to the front of a (possibly empty) list
           def    2      SPECIAL FORM: Set a value
        errors    1+     SPECIAL FORM: Error checking (for tests)
          fuse    1      Fuse a list of numbers or atoms into a single atom
          help    0      Print this message
            is    1      Assert that the argument is truthy (not ())
        lambda    1+     SPECIAL FORM: Create a function
           len    1      Return the length of a list
          neg?    1      Return true if the (numeric) argument is negative, else ()
           not    1      Return t if the argument is nil, () otherwise
          pos?    1      Return true if the (numeric) argument is positive, else ()
         print    0+     Print the arguments
         quote    1      SPECIAL FORM: Quote an expression
     randigits    1      Return a list of random digits of the given length
         split    0      Split an atom or number into a list of single-digit numbers or single-character atoms
          test    0+     Establish a testing block (return last expression)
         zero?    1      Return t if the argument is zero, () otherwise
    > ^D
    $
<!-- END EXAMPLES -->

# CI/CD

A `Makefile` exists for convenience (combining testing, linting and build), and a `Dockerfile` is  used by a GitHub action for this project to email an alert if code is pushed which fails the build.

# Emacs Integration

If you are using Emacs, you can set it up to work with `l1` as an "inferior
lisp" process as described in [the Emacs manual](https://www.gnu.org/software/emacs/manual/html_node/emacs/External-Lisp.html).
I currently derive a new major mode from the base `lisp-mode` and bind a few
keys for convenience as follows:

    (define-derived-mode l1-mode
      lisp-mode "L1 Mode"
      "Major mode for L1 Lisp code"
      (setq inferior-lisp-program (executable-find "l1")
      (paredit-mode 1)
      (define-key l1-mode-map (kbd "s-i") 'lisp-eval-last-sexp)
      (define-key l1-mode-map (kbd "s-I") 'lisp-eval-form-and-next)
      (define-key l1-mode-map (kbd "C-o j") 'run-lisp))

    (add-to-list 'auto-mode-alist '("\\.l1" . l1-mode))

If `l1` has been installed on your path, `M-x run-lisp` or using the appropriate
keybinding should be enough to start a REPL within Emacs and start sending
expressions to it.

# Goals

- Learn more about Lisp as a model for computation by building a Lisp with sufficient power to [implement itself](http://www.paulgraham.com/rootsoflisp.html);
- Improve my Go skills;
- Build a small, fast-loading Lisp that I can extend how I like;
- Possibly implement Curses-based terminal control for text games, command line utilities, ...;

# Non-goals

- Backwards compatibility with any existing, popular Lisp.
- Stability (for now) -- everything is subject to change.

# Resources / Further Reading

- [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sites/default/files/sicp/index.html).  Classic MIT
  text, presents several Lisp evaluation models, written in Scheme.
- [Crafting Interpreters](https://craftinginterpreters.com/) book / website.  Stunning, thorough,
  approachable and beautiful book on building a language in Java and
  in C.
- Donovan & Kernighan, [The Go Programming Language](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440). Great Go reference.
- Rob Pike, [Lexical Scanning in Go](https://www.youtube.com/watch?v=HxaD_trXwRE) (YouTube).  I took the code described in this talk and spun it out into [its own package](https://github.com/eigenhombre/lexutil/) for reuse in `l1`.
- A [more detailed blog post](http://johnj.com/posts/l1/) on `l1`.

# License

Copyright Â© 2022, John Jacobsen. MIT License.

# Disclaimer

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
