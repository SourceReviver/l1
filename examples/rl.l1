#!/usr/bin/env l1

;; Beginnings of a roguelike game

(defn listlen (msg)
  (let ((words-len (apply + (map (comp len split) msg)))
        (spaces-len (dec (len msg))))
    (+ words-len spaces-len)))

(defn write-width-centered (h msg)
  (let* ((dims (screen-size))
         (w (- (/ (car dims) 2)
               (/ (listlen msg) 2))))
    (screen-write w h msg)))

(defn press-any-key () (screen-get-key))

(defn intro ()
  (screen-clear)
  (write-width-centered 10 '(O N O M A T))
  (write-width-centered 12 '(press any key to continue))
  (press-any-key)
  (screen-clear))

(def MAXROOM 20)
(def MINROOM 4)

(defn make-room (screen-dims)
  (let* ((w (first screen-dims))
         (h (second screen-dims))
         (room-width (min MAXROOM
                          (max MINROOM
                               (inc (randint (dec w))))))
         (room-height (min MAXROOM
                           (max MINROOM
                                (inc (randint (dec h))))))
         (room-pos-w (inc (randint (inc (- w room-width)))))
         (room-pos-h (inc (randint (inc (- h room-height))))))
    (list room-pos-w
          room-pos-h
          room-width
          room-height)))

(defn room-x (room)      (nth 0 room))
(defn room-y (room)      (nth 1 room))
(defn room-width (room)  (nth 2 room))
(defn room-height (room) (nth 3 room))

(defn random-position-in-room (room)
  (list (+ (room-x room) (randint (room-width room)))
        (+ (room-y room) (randint (room-height room)))))

(defn draw-room (room)
  (foreach h (map (partial + (room-y room))
                  (range (room-height room)))
    (screen-write (room-x room) h
                  (list (fuse (repeat (room-width room)
                                      PERIOD))))))

(defn make-player (player-position)
  player-position)

(defn player-x (player)
  (first player))

(defn player-y (player)
  (second player))

(defn draw-player (player)
  (screen-write (player-x player)
                (player-y player)
                (list ATSIGN)))

(defn move-player-y (player incr)
  (list (first player)
        (+ (second player) incr)))

(defn update-pos (l n f)
  (doc (update nth position of a list by applying f to the
               value of the nth element, leaving the others
               unchanged))
  (when (< n (len l))
    (concat (take n l)
            (list (f (nth n l)))
            (drop (inc n) l))))

(defn move-player (player delta)
  (list (+ (player-x player) (first delta))
        (+ (player-y player) (second delta))))

(defn valid-move (room player delta)
  (and (<= (room-x room)
           (+ (player-x player) (first delta))
           (+ (room-x room) (room-width room) -1))
       (<= (room-y room)
           (+ (player-y player) (second delta))
           (+ (room-y room) (room-height room) -1))))

(defn make-monster (room)
  (list* 'X (random-position-in-room room)))

(defn monster-pos (monster) (cdr monster))

(defn monster-x (monster) (cadr monster))

(defn monster-y (monster) (caddr monster))

(defn monster-char (monster) (car monster))

(defn monsters-for-room (room)
  (repeatedly (inc (randint 4))
              (partial make-monster room)))

(defn draw-monster (monster)
  (screen-write (monster-x monster)
                (monster-y monster)
                (list (monster-char monster))))

(defn move-monster (room player monster))

(defmacro prepend! (l x)
  `(set! ~l (cons ~x ~l)))

;; main ............
(progn
  (with-screen
      (intro)
    (let* ((dims (screen-size))
           (room (make-room dims))
           (player-pos (random-position-in-room room))
           (player (make-player player-pos))
           (continue t)
           (move-if-valid (lambda (coords)
                            (when (valid-move room player coords)
                              (set! player (move-player player coords)))))
           (monsters (monsters-for-room room))
           (update-monsters!
             (lambda ()
               (prepend! monsters (make-monster room))
               (foreach m monsters
                 (draw-monster m)))))
      (while continue
        (draw-room room)
        (draw-player player)
        (update-monsters!)
        (let ((k (screen-get-key)))
          (cond
            ((= k 'q) (set! continue ()))
            ((or (= k 'h) (= k 'LEFTARROW))
             (move-if-valid '(-1 0)))
            ((or (= k 'l) (= k 'RIGHTARROW))
             (move-if-valid '(1 0)))
            ((or (= k 'k) (= k 'UPARROW))
             (move-if-valid '(0 -1)))
            ((or (= k 'j) (= k 'DOWNARROW))
             (move-if-valid '(0 1)))
            ((= k 'y) (move-if-valid '(-1 -1)))
            ((= k 'u) (move-if-valid '(1 -1)))
            ((= k 'b) (move-if-valid '(-1 1)))
            ((= k 'n) (move-if-valid '(1 1))))))))
  (println)
  (printl (exclaim '(thanks for playing)))
  (println))
